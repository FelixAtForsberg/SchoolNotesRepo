// WORDS
// =====
// AFFIX  - BEFORE OR AFTER             (or infix/circumfix/transfix)             https://en.wikipedia.org/wiki/Affix 
// PREFIX - BEFORE                      (prefix)
// SUFFIX - AFTER                       (postfix)

// Implicity Typed = using var 

// Argument:    Passed to the function [call]
// Parameter: Used within the function [definition]

// Casting
// =======
// Implicit Casting -> (silently converts type) float = int
// Explicit Casting -> (explicity expressed) float = (float)int
// Via Method
// Cast Up -> BaseClass   (Casting to child)  (Information lost)
// Cast Down -> Inherited (Casting to parent) (Information gained)

// 'as' - keyword 
// if (animal is Dog dog) {...}  -  check is dog AND assign Dog dog  

// Polymorphism
// =====
// Subtyping   -> Subtype Implements Interface, Compatability. 
// Inheritance -> Reuse of implementation,      Superset.

  // Variance
  // ========
  // Contravariance = Allows less derived than specified (in)      //  Base  -> SomeClass -> [SomeClassChild]     'Base' contravariant to 'SomeClassChild'
  // Covariance     = Allows more derived than specified (out)     // [Base] -> SomeClass ->  SomeClassChild      'SomeClassChild' covariant to 'Base'

  // https://en.wikipedia.org/wiki/Covariant_return_type
  // https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)

// Compiler
// =======
// Lexical Analysis         -> the first phase of the compiler (a scanner). Converts High level input program into a sequence of Tokens.
// ├╴Token                  -> (lexical  token) - a sequence of characters that can be treated as a unit in the grammar of the programming languages. What the compiler reads, not comments/whitespace
// │ └╴Identifier (Symbol)  -> (lexical) token that refers to an entity in a languaget
// │
// └╴Tokenization           -> Turning text into Tokens (a token stream)
// Debug Symbols            -> Map between source code and compiled binary, enables debuggers to retain/map source code names for generated bytecode
// compilation units        -> Source File(s)

// https://www.geeksforgeeks.org/introduction-of-lexical-analysis/
// https://en.wikipedia.org/wiki/Identifier_(computer_languages)
// https://en.wikipedia.org/wiki/Symbol_(programming)

// Runtime
// =======
// Runtime  ->  Compiler generates code that targets the runtime
// CLR      ->  Common Language Runtime   (.NET runtime environment)


// C# Specification
// ================
// Uses ANTLR Notation
// $ Attribute    @ Action    | Alternative     * 0 or more     + 1 or more     . wildcard    ? optional OR semantic predicate
// semantic predicate -> 

// https://stackoverflow.com/questions/3056441/what-is-a-semantic-predicate-in-antlr
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/readme
// https://theantlrguy.atlassian.net/wiki/spaces/ANTLR3/pages/2687036/ANTLR+Cheat+Sheet



A process has 5 different areas of memory allocated

1. Code - text segment
2. Initialized data  – .data segment
3. Uninitialized data – .bss segment
4. Heap
5. Stack

+--------------------------+
|                          |
| command line             |
| arguments                |
| (argc and argv[ ])       |
|                          |
+--------------------------+
| Stack (grows-downwards)  |
|                          |
|                          |
|                          |
|                          |
| F R E E                  |
| S P A C E                |
|                          |
|                          |
|                          |
|                          |
| (grows upwards) Heap     |
+--------------------------+
|                          |
| Initialized data         |
| segment                  |
|                          |
+--------------------------+
|                          |
| Initialized to           |
| Zero (BSS)               |
|                          |
+--------------------------+
|                          |
| Program Code             |
|                          |
+--------------------------+

// ================
//      Syntax
// ================

// Members - https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members
//           ^ Fields Constants Properties Methods Events Operators Indexers Constructors Finalizers Nested Types

// Fields  - https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/fields


// --- Statments ---      actions that a program takes are expressed in statements

int counter;    // Declare, Declaration (statement)
int counter = 1 // Declare, Declaration statement with initializer
counter = 1;    // Assignment  (statement)

// ---------- Members ----------
// [class, struct]
// member = Fields  Constants  Properties  Methods  
//          Events  Operators  Indexers    Finalizers  Nested Types 

field       // variable, class scope
constant    // variable, class scope, read-only   set at compile-time only
property    // method,   accessed as if they were "fields"
            //           provide "protection" for a class field 
Method          // method,   class function, describe action + optinal return value
Event           // delegate
Operator        // method,   public static method, operator overloading
Indexer         //           array-like accessor
Constructor     // method,   called on creating
Finalizer       // method,   destructor (used rarely in c#)
Nested Types    // type,     types declare within another type

// ===============
//   Collections 
// ===============

Array is a REFERENCE TYPE // is passed by reference?
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/reference-types

List


// ==============================
// Value Types - Numbers (Integer)
// ==============================
// -------- Value Types:  Number --------
bool            // 1b       true false

byte            // 8b          0 .. 255       
sbyte           //          -128 .. 127     

short           // 16b    32,768 .. 32,767
ushort          //             0 .. 65,535

int             // 32b    -2,147,483,648 .. 2,147,483,647 
uint            //                       0 .. 4,294,967,295

long            // 64b    -9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807
ulong           //                                   0 .. 18,446,744,073,709,551,615


nint            // (platform) int32  or int64 
nuint           // (platform) uint32 or uint64

// ==============================
// Value Types - Numbers (Decimal) 
// ==============================
//                 Size        Precision
float           // 4  bytes    ~6-9   digits
double          // 8  bytes    ~15-17 digits
decimal         // 16 bytes    ~28-29 digits

// ==============================
// Value Types - Text  
// ==============================
char            // 16b    default: \0   (aka U+0000)     U+0000 .. U+FFFF
// = 'j'        //  character literal
// = '\u006A'   //  unicode escape sequence    
// = '\x006A'   //  hexademical escape sequence    
// = (char)106 

string


// ==============================
// Types - Exceptions  
// ==============================
// https://www.tutorialsteacher.com/csharp/csharp-exception
// ArgumentException - https://learn.microsoft.com/en-us/dotnet/api/system.argumentexception.-ctor?view=net-6.0
// https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/using-standard-exception-types


// Exception Do-s and Dont's -- "Using Standard Exception Types"
// MSDN: Do not throw/catch: (System.)"Exception", "SystemException"
//       Do not throw/derive "ApplicationException"

// (Incomplete)
// Hierarchy
Exception
├─ApplicationException
└─SystemException
  ├─── ArithmeticException
  │    └─ DivideByZeroException 
  ├─── IOException
  │    └─ FileNotFoundException
  ├─── TimeoutException
  ├───IndexOutOfRangeException
  ├─── FormatException
  ├─── AccessViolationException
  ├─── ComException
  ├─── ExternalException
  ├─── InvalidOperationException  // object is in an inappropriate state
  ├─── NullReferenceException
  └─── ArgumentException          // Bad arguments passed to member
       │ // for sub-types, set (or use overloads):
       │ // '.ParamName = <nameOfParam>' AND '.value = <name of implicit value>'
       ├─ ArgumentNullException       
       └─ ArgumentOutOfRangeException

// [cs]
// ==============================
// Function/Method Types
// ==============================
delegate // pointer to a method
  func      // .. with input and return type 
  action    // .. with no return type (void)
  predicate // .. that evaluates and returns a bool

// ==== Delegates - Signatures ====
func      - delegate TResult Func<in T, out TResult>(T arg);
predicate - delegate bool    Predicate<in T>(T obj);



// ==========================================
//              Statements
// ==========================================

// --------- Statements - Iteration ---------  
// foreach
//      uses .GetEnumerator() - Can be extension method
//            └> .


// ==========================================
//              Operators
// ==========================================
[cs] 

// ============= ASSIGNMENT =============
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/assignment-operator
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator

// ----------- ref assignment
//             = ref
ref double arrayElement = ref arr[0]; 
//  aliases left hand operand
// left side must be: ref local, ref readonly local, "ref field" in "ref struct"

// ----------- compound assignment
//             op=
x op= y // same as: x = x op y

// ----------- null-coalescing assignment
//             ??=
a ??= 0 // if 'a' is null, a=0 ELSE a=a

// ============= BINARY =============
// TODO


// ============= ARRAY / INDEX / RANGE =============

// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators
// ..          "All values"

// EXAMPLES:
// Start = Inclusive
// End   = Exclusive
//   oneThroughTen = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
// 
//   [0..3]     ->  1, 2, 3                             Range   (Index 0 to Index 2)
//   [3..5]     ->  4, 5                                  
//   [0..^0]    ->  1, 2, 3, 4, 5, 6, 7, 8, 9, 10       Range + IndexFromEnd               
//   [2..^0]    ->  3, 4, 5, 6, 7, 8, 9, 10                                           
//   [0..^3]    ->  1, 2, 3, 4, 5, 6, 7                  
//   [3..^4]    ->  4, 5, 6                              
//   [^2..^0]   ->  9, 10                               IndexFromEnd + Range + IndexFromEnd
//   [^4..^2]   ->  7, 8                                    

// "ABCDEF" [0..3] -> ABC
// "ABCDEF"

// ----------- Index From End
//             ^a
int[] subset = numbers[^a];


// ----------- Range
//             a..b   
int[] subset = numbers[a..b];



[/cs]
// ===================
//       Structures
// ===================

// ----- class -----
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class
class

// ---- class -- getters and setters ----

// questions:
// if get can still be set in constructor what is {init;}
// difference to readonly keyword?

// -- getters
// under the hood generates methods 
// <access-modifier> <type> field { [return] }
get { <method body> } -> get_fieldName() // internally generates methods 

// read-only - only has setter ({ get; })
//             read-only CAN STILL be SET in constructor

// -- setters
set { <method body> } -> set_fieldName(T field)

// auto property
{ get; set; } // no body

// if getters and setters are internally methods (or compile to methods) does c# have extension properties

// ----- struct -----
// inherits: class -> System.ValueType -> struct
// modifiers: new, public, protected, internal, private
//            partial, 
// never abstract, implicitly sealed
struct
ref struct

record struct 
// Short Syntax for a struct that has a constructor with fields of same name
// if given 'readonly' modifier; members get defined as {get; init;}
readonly record struct ColorPair(ConsoleColor? Foreground, ConsoleColor? Background);



// Parameterless struct constructors - https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/parameterless-struct-constructors
// Structs (draft specification) - https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/structs
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/ref-struct




// How do I make a struct immutable? - https://stackoverflow.com/questions/36780200/how-do-i-make-a-struct-immutable

    class             vs             struct
// reference type                  value type
// inheritance                     no inheritance
// reference can be null           cannot be null reference
// can have destructor             no destructor
// decl can initialize members     decl cannot initialize members

// When To Use Struct  https://www.c-sharpcorner.com/article/what-is-structure-and-when-to-use-in-c-sharp/
// * small collections of value-types 
// * all member fields are of value type
// gets copied when passed

// ---- interface ----
// https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface
// "contract" - outline (aka signature) but no body

interface
  Members:
        // https://devblogs.microsoft.com/dotnet/default-implementations-in-interfaces/
        https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/default-interface-methods-versions
      method with body; "Default implementation" 
        if implementing class/struct doesn't implement, uses this implementation
    
// effects in practice: 
  sealed/private needs body; cannot be part of interface as a "contract"
        

// ---- enum ----
enum

// ---- array ----
//https://learn.microsoft.com/en-us/dotnet/api/system.array.createinstance?view=net-7.0
array


// ============================
//     Keywords - Modifiers
// ============================
// C# Keywords (ALL) - https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
// CheatSheet        - http://www.diranieh.com/NETCSharp/Modifiers.htm

// Contextual Keywords - https://www.tutorialspoint.com/What-are-contextual-keywords-in-Chash

// ------ Keywords - Access Modifiers ------
public          
internal        // public inside the project 
protected       // class & derived    
private         // default, class ONLY
// ------ Keywords - Method Parameter Modifiers ------
this (for extension methods, in static method, prefix first argument type)
in      // pass reference - readonly, cannot be modified in method
out     // pass reference - can be uninitialized (unlike ref)
ref     // pass reference - must be initalized   (unlike out) 
params  // arguments become an array - like python *args
// ------ Keywords - Namespace Parameter Modifiers ------
namespace
using
extern alias
// ------ Keywords - Contextual
required //                https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required


// ------ Keywords - Modifiers ------
abstract        // "base class" - no instantion, may have abstract members
// must provide implementation for all interface members
// children must implement all abstract methods/properties
// CANNOT use: static, virtual override in abstract declaration
async
const // not variables
event
extern // implemented externally
in
new
out
override // sealed override - should not be overriden again
readonly
sealed // prevents inheritance
static 
unsafe // involves pointers
virtual
volatile // allow multithreaded access

// --- Abstract VS Virtual
// Generally: Abstract - No default implementation
//            Virtual -  Has defaults, allow overrides

//  Abstract - Methods: No base implementation = MUST override -- optional if implemented
//  Abstract - Property: 
//  Virtual  - Methods: Base implementation required, optional child override
//                

// -- Interface:
//  I know what I want them to do, 
//  I don't care how they do it: 

// -- Abstract Class:
//  I know what I want them to do
//  I don't care how they do some of it, 
//  but I've got firm ideas on how they'll (or at least most of them) do other bits

// -- Concrete Class + Virtual Members:
//  I know what I want them to do
//  and how most of them will do it 

// https://stackoverflow.com/questions/14728761/difference-between-virtual-and-abstract-methods
// https://stackoverflow.com/questions/12254438/not-sure-when-to-use-an-abstract-property-and-when-not

// https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract

// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record
record // A record or a record class declares a reference type
// -- Record Example ----------------------------------
[cs]
public record Person(string FirstName, string LastName);

public static void Main()
{
    Person person = new("Nancy", "Davolio");
    Console.WriteLine(person);
    // output: Person { FirstName = Nancy, LastName = Davolio }
}
[cs]
// ----------------------------------------------------

// ========
// Loops 
// ========

break // end current iteration, goto end
next  // end current iteration, goto start (next iteration)


// --------------------
// Text, Strings, Chars
// --------------------

"a" // Double Quotes = String
'a' // Single Quotes = Char


// "Rules"
// https://stackoverflow.com/questions/24551/initialize-class-fields-in-constructor-or-at-declaration
Initiliaze in Class Fields in Constructor or Declaration?




// ========================
// Async
// ========================
// https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/
async
await
Task
    .WhenAll
    .WhenAny

// =============
// Contexts & Pre-Processor
// =============

// Preprocessor Directives  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives
// nullable                 https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references#nullable-contexts

#nullable [enable|disable|annotations|warnings]
//             | Dereference | Assignment |  Reference       Suffix      Operator 
//             | Warning     | Warning    |  Types           ?           !
// ------------+-------------+------------+----------------------------------------
// disable:    | NO          | NO         |  ALL NULLABLE                   
// enable:     | YES         | YES        |  NON-UNLESS ?                    
// warnings:   | YES         | N/A        |  ALL NOT NULL AT METHOD BRACE     
// annotations:| NO          | NO         |                                   



// Conditional Compilation
#define
#undef

#if cond
#elif cond
#else
#endif

// editor - collapsible
#region
#endregion

// Compiler Errors
#error                       // Generate
#warning                     // Generate
#line hidden|filename        // Change Line-Number printed with messages

#pragma // enable disable warnings


// ==================
// Extension Method
// ==================
// https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method

// To define and call the extension method
1. Define a static class to contain the extension method.
2. The class must be visible to client code. 
3. Implement the extension method as a static method with at least the same visibility as the containing class.
4. first parameter of the method specifies the type that the method operates on; it must be preceded with the this modifier.
5. In calling code, add a using directive to specify the namespace that contains the extension method class.
6. Call the methods as if they were instance methods on the type.
7. Note that the first parameter is not specified by calling code because it represents the type on which the operator is being applied, and the compiler already knows the type of your object. You only have to provide arguments for parameters 2 through n.


// ==================
// Strings
// ==================

//    -------- Terminal --------
// Escape Sequences
// https://www.tutorialspoint.com/Ways-to-print-escape-characters-in-Chash
// https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences

\a  "bell"            \u0007 
\b  "backspace"       \u0008 
\t  "tab"             \u0009    
\r  "carriage return" \u000D 

\v  "vertical tab"    \u000B 
\f  "form feed"       \u000C 
\n  "newline"         \u000A 
\e  "escape"          \u001B 

\x  "hex"
\u  "unicode"

// xterm
ESC 7   DECSC   DEC Save Cursor 
ESC 8   DECRC   DEC Restore Cursor 



// --------- String Creation


// StringBuilder 

// "When to use String vs. StringBuilder in .NET Core"  https://www.infoworld.com/article/3616600/when-to-use-string-vs-stringbuilder-in-net-core.html
//   Benchmarks: String Concat VS StringBuilder
//   Examples: StringBuilder allocations using a reusable pool 

// https://learn.microsoft.com/en-us/dotnet/api/system.string.create?view=net-6.0
// String.Create



// =============================
// Principles
// =============================
// https://stackoverflow.com/questions/31317141/whats-the-difference-between-design-patterns-and-design-principles
// Principle: High-level guide lines you must/should follow

// Aggregation
// TODO

// Composition
// TODO

// Dependency Inversion Principle
// TODO

// =============================
// Patterns
// =============================
// https://stackoverflow.com/questions/31317141/whats-the-difference-between-design-patterns-and-design-principles
// Pattern: related to the implementation



// ============= Dependency Injection  VS  Composition  VS Aggregation =============
// https://stackoverflow.com/questions/21022012/difference-between-dependency-and-composition



// 
// ============= "Fluent Interface" =============    
// OOP Object that relies heavily on "Method Chaining"      https://en.wikipedia.org/wiki/Fluent_interface

// Method Chaining 
// ----------------
// -- Usage:
yObj.AddItem(mItem).AddItem(mItem2).AddItem(mItem3);
// -- Code:
// https://stackoverflow.com/questions/1119799/method-chaining-in-c-sharp
public MyCollection AddItem( MyItem item )
{
   // internal logic...

   return this;
}
// ------------
// Alternatives (to method chaining):
// ------------- params -------------
// -- Usage:
coll.AddItems( first, second, third );
coll.AddItems( first, second, third, fourth, fifth );
// -- Code:
public void AddItems( params MyItem[] items )
{
    foreach( var item in items )
        m_innerCollection.Add( item );
}

// ------------- IEnumerable -------------
public void AddItems( IEnumerable<MyClass> items )
{
    foreach( var item in items )
         m_innerCollection.Add( item );
}
// ------------- Initializer Syntax -------------
var myColl = new MyCollection { first, second, third, ... };

class XYZ : IEnumerable<SomeType>
{
    
} 
XYZ xyzClass = new XYZ() {
    // ...
} 



// ==================
// Runtime Hacks
// ==================

// Reflection
// https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection
// https://learn.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection
// https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit?view=net-6.0

typeof()

// https://learn.microsoft.com/en-us/dotnet/api/system.array?redirectedfrom=MSDN&view=net-6.0

// Managed vs. unmanaged types
// https://stackoverflow.com/questions/54790276/managed-vs-unmanaged-types

// c# Array Source Code 
// https://referencesource.microsoft.com/#mscorlib/system/array.cs
// https://github.com/dotnet/coreclr/blob/bc146608854d1db9cdbcc0b08029a87754e12b49/src/classlibnative/bcltype/arraynative.cpp#L226

// Extension Property Workarounds
// https://stackoverflow.com/questions/619033/does-c-sharp-have-extension-properties

// ExpandoObject Class
//  Represents an object whose members can be dynamically added and removed at run time
//  https://learn.microsoft.com/en-us/dotnet/api/system.dynamic.expandoobject?view=net-7.0

// Unsafe code -- Swap pointers to type
// https://stackoverflow.com/questions/1862561/replacing-a-net-type-at-runtime

// DynamicObject Class
// Provides a base class for specifying dynamic behavior at run time
// https://learn.microsoft.com/en-us/dotnet/api/system.dynamic.dynamicobject?redirectedfrom=MSDN&view=net-6.0

// how do I overload []
// https://stackoverflow.com/questions/424669/how-do-i-overload-the-operator-in-c-sharp
public int this[int key]
{
    get => GetValue(key);
    set => SetValue(key, value);
}


// Unsafe code, pointer types, and function pointers
// https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code



// ======================
// LINQ
// ======================
// TODO


// =======================================================================================================================================
// Generics   
// =======================================================================================================================================

// ---------------------------------------------------------------------------------------------------------------------------------------
// Variance
// Covariant - Contravariant - Invariant
// Covariance and contravariance are collectively referred to as variance
// ---------------------------------------------------------------------------------------------------------------------------------------
// https://learn.microsoft.com/en-us/dotnet/standard/generics
// https://learn.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance
// Generics in .NET
// ---------------------------------------------------------------------------------------------------------------------------------------
//  Generic Type Parameters support covariance and contravariance contravariance to provide greater flexibility in assigning and using generic types
//  Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified. 

//  -------------------- Covariance --------------------
// Less Generic (More Derived)
// Enables you to use a more derived type than originally specified.
// You can assign an instance of IEnumerable<Derived> to a variable of type IEnumerable<Base>.

// Covariant Parameter:
out <parameter>

//  -------------------- Contravariance --------------------
// More Generic (Less Derived)
// Enables you to use a more generic (less derived) type than originally specified.
// You can assign an instance of Action<Base> to a variable of type Action<Derived>.

// Contravariant Parameter:
in <parameter>

// -------------------- Invariance --------------------
// Only the same
// Means that you can use only the type originally specified. An invariant generic type parameter is neither covariant nor contravariant.
// You cannot assign an instance of List<Base> to a variable of type List<Derived> or vice versa.

// Default when not marked with "out <parameter>" or "in <parameter>" 

// ---------------------------------------------------------------------------------------------------------------------------------------
// Generic Interface
// ---------------------------------------------------------------------------------------------------------------------------------------

//  ------- Example - Generic Interface Definition ------- 
public interface ICounter<T>
{
    int Count { get; }
    T Get(int index);
}
// ------- Example - Implement Generic Interface ---------
public interface IPersons<T> : ICounter<T>
{
    void Add(T item);
}
// ------- Example - Class Defintion ---------------------
public class People<T> : IPersons<T>
{ /* ... */  }


// https://stackoverflow.com/questions/2007429/inherit-from-a-generic-base-class-apply-a-constraint-and-implement-an-interfac
// ------- Example - Class Defintion ---------------------
class DerivedFoo<T1, T2> : ParentFoo<T1, T2>, IFoo where T2 : IBar
{
    /*...*/
}
// ------- Example - Class Defintion ---------------------
public interface IFoo {}
public interface IBar {}

public class ParentFoo<T,T1> { }
public class DerivedFoo<T, T1> : ParentFoo<T, T1>, IFoo where T1 : IBar { }




// ---------------------------------------------------------------------------------------------------------------------------------------
// Constraints on type parameters (C# Programming Guide)
// https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters
// ---------------------------------------------------------------------------------------------------------------------------------------
// where T : <symbol>         // Non-Nullable
// where T : <symbol>?        // Nullable OR non-nullable type
// ---------------------------------------------------------------------------------------------------------------------------------------
// Constraint
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : <base class name>   //   Must be/derive from the specified base class. 
                              //   In Nullable Context: T must be a non-nullable reference type derived from the specified base class.
where T : <base class name>?  //   Nullable/non-nullable type derived from specified base class.
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : <interface name>    //   Be/implements specified Interface. Can be Generic Interface.
                              //   +Multiple
                              //   +Reference type (Non-nullable) 

where T : <interface name>?   //   Be/implements specified Interface
                              //   +Reference type (nullable/not nullable)
                              //   +Value     type (non-nullable)
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : class               //   (eg: array, class, delegate, interface)
                              //   +Reference type (non-nullable)
                              
where T : class?              //   +Reference type (nullable/non-nullable)
                              //   
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : default             //   Resolves ambiguity: when an unconstrained type parameter when you override a method or provide an explicit interface implementation. 
                              //   Implies the base method without either the class or struct constraint.
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : new()               //   Argument must have a public parameterless constructor. 
                              //   When used together with other constraints, the new() constraint must be specified last. 
                              //   Cannot combine: struct, unmanaged constraints
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : notnull             //   Non-nullable type. The argument can be a non-nullable reference type or a non-nullable value type.
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : struct              //   Value type (Non-nullable)  
                              //   Implies: new() (Because all value types have an accessible parameterless constructor)
                              //   Cannot Combine: unmanaged constraint
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : U                   //   Be/derive from the argument supplied for U. 
                              //   Nullable Context: if U is a non-nullable type, T must be non-nullable reference type. 
                              //                     If U is a     nullable type, T can be nullable/non-nullable.
// ---------------------------------------------------------------------------------------------------------------------------------------
where T : unmanaged           //   +Unmanaged Type (Non-nullable)
                              //   Implies: struct constraint
                              //   Cannot combine: struct, new() constraints
